{% extends 'base.html' %}
{% load static %}

{% block title %}
  Product List - Online Grocery
{% endblock %}

{% block content %}
<div class="container">
  <h1>Product List</h1>

  <div class="row">
    <!-- Left Column: Collapsible Category Menu -->
    <div class="col-md-3 mb-4">
      <div class="card">
        <div class="card-header">
          <strong>Categories</strong>
        </div>

        <ul class="list-group list-group-flush">
          {% for level1, node in category_tree.items %}
            <li class="list-group-item">
              {% if node.items %}
                <a
                  class="d-flex justify-content-between align-items-center text-decoration-none"
                  data-bs-toggle="collapse"
                  href="#cat-{{ forloop.counter }}"
                  role="button"
                  aria-expanded="false"
                  aria-controls="cat-{{ forloop.counter }}"
                >
                  <strong>{{ level1 }}</strong>
                  <span class="ms-2"><i class="bi bi-caret-down-fill"></i></span>
                </a>

                <ul class="collapse ms-4 mt-2" id="cat-{{ forloop.counter }}" style="list-style-type: disc;">
                  {% for level2, _ in node.items %}
                    <li style="list-style-position: outside;">
                      <a class="text-decoration-none {% if request.GET.l1 == level1 and request.GET.l2 == level2 %}fw-bold{% endif %}"
                         href="?l1={{ level1|urlencode }}&l2={{ level2|urlencode }}"
                         {% if request.GET.l1 == level1 and request.GET.l2 == level2 %}aria-current="page"{% endif %}>
                        {{ level2 }}
                      </a>
                    </li>
                  {% endfor %}
                </ul>
              {% else %}
                <a class="text-decoration-none d-block {% if request.GET.l1 == level1 and not request.GET.l2 %}fw-bold{% endif %}"
                   href="?l1={{ level1|urlencode }}"
                   {% if request.GET.l1 == level1 and not request.GET.l2 %}aria-current="page"{% endif %}>
                  <strong>{{ level1 }}</strong>
                </a>
              {% endif %}
            </li>
          {% empty %}
            <li class="list-group-item text-muted">No categories found.</li>
          {% endfor %}
        </ul>

      </div>
    </div>

    <!-- Right Column: Search Form & Product Listing -->
    <div class="col-md-9">
      <!-- Search Form -->
      {% comment %} <form method="GET" action="" class="mb-3">
        <div class="input-group">
          <input
            type="text"
            name="q"
            class="form-control"
            placeholder="Search for products..."
            value="{{ request.GET.q }}"
          />
          <button class="btn btn-outline-secondary" type="submit">
            Search
          </button>
        </div>
      </form> {% endcomment %}

<form method="GET" action="" class="mb-3" id="search-form">
  {# preserve current filters when searching #}
  {% if request.GET.l1 %}<input type="hidden" name="l1" id="l1-field" value="{{ request.GET.l1 }}">{% else %}<input type="hidden" name="l1" id="l1-field">{% endif %}
  {% if request.GET.l2 %}<input type="hidden" name="l2" id="l2-field" value="{{ request.GET.l2 }}">{% else %}<input type="hidden" name="l2" id="l2-field">{% endif %}

  <div class="input-group">
    <input
      type="text"
      name="q"
      id="search-input"
      class="form-control"
      placeholder="Search for products or categories..."
      value="{{ request.GET.q }}"
      list="category-suggestions"
      autocomplete="off"
      aria-label="Search products"
    />
    <button class="btn btn-outline-secondary" type="submit" aria-label="Search">
      Search
    </button>
  </div>

  {# As-you-type dropdown suggestions: Level-1, Level-2, and combined "L1 - L2" #}
  <datalist id="category-suggestions">
    {% for level1, node in category_tree.items %}
      <option value="{{ level1 }}"></option>
      {% if node.items %}
        {% for level2, _ in node.items %}
          <option value="{{ level2 }}"></option>
          <option value="{{ level1 }} - {{ level2 }}"></option>
        {% endfor %}
      {% endif %}
    {% endfor %}
  </datalist>
</form>

{# Safe JSON payloads for exact-matching on submit #}
{{ level1_names|json_script:"level1-names" }}
{{ level2_names|json_script:"level2-names" }}

      

      <!-- Product Container -->
      <!-- We'll insert initial products here, and then append more as the user scrolls -->
      <div class="row gy-4" id="product-container">
        {% for product in products %}
          {% include '_catalog/product_item.html' with product=product %}
        {% empty %}
          <div class="col-12">
            <p class="text-muted">No products matched your filters.
              <a href="{% url 'product_list' %}">Clear filters</a>
            </p>
          </div>
        {% endfor %}
      </div>

      <!-- A hidden element to store the next page number or URL -->
{% if page_obj.has_next %}
  <input type="hidden" id="next-page" value="{{ page_obj.next_page_number }}">
{% else %}
  <input type="hidden" id="next-page" value="">
{% endif %}

      <!-- Sentinel DIV for the Intersection Observer -->
      <div id="infinite-scroll-sentinel" class="py-3 text-center">
        <!-- We'll watch this element to trigger loads -->
        <span id="loading-spinner" style="display: none;">
          <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading more products...</span>
          </div>
        </span>
      </div>

    </div> <!-- End Right Column -->
  </div> <!-- End .row -->
</div>

<!-- JavaScript for Infinite Scroll -->
<script>
  document.addEventListener('DOMContentLoaded', function () {
    const sentinel = document.getElementById('infinite-scroll-sentinel');
    const loadingSpinner = document.getElementById('loading-spinner');
    const nextPageInput = document.getElementById('next-page');
    const productContainer = document.getElementById('product-container');

    // If there's no next page, we can disable infinite scroll
    if (!nextPageInput.value) {
      // No more pages to load
      return;
    }

    // Create an Intersection Observer
    const observer = new IntersectionObserver(async (entries) => {
      if (entries.some(e => e.isIntersecting)) {
        loadingSpinner.style.display = 'inline-block';
        let page = nextPageInput.value;

        try {
          let url = "{% url 'load_more_products' %}?page=" + page;

          {% if request.GET.q %}
          url += "&q={{ request.GET.q|urlencode }}";
          {% endif %}

          // Always forward current l1/l2 from the URL
          const params = new URLSearchParams(window.location.search);
          if (params.get('l1')) url += "&l1=" + encodeURIComponent(params.get('l1'));
          if (params.get('l2')) url += "&l2=" + encodeURIComponent(params.get('l2'));


          // Fetch the next set of products (HTML or JSON)
          const response = await fetch(url, {
            headers: {
              'X-Requested-With': 'XMLHttpRequest'
            }
          });
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }

          // Let's assume it returns HTML to be appended
          const data = await response.text();

          // Append the returned HTML to the product container
          productContainer.insertAdjacentHTML('beforeend', data);

          // We'll assume the partial includes a <script> or a hidden input
          // that updates or includes the new "next_page" value. Alternatively,
          // return it via a custom header or JSON. For simplicity, let's say
          // the view returns JSON with new HTML and next_page.

          // But if you're returning pure HTML, you must find a way to update
          // the next page. For demonstration, let's assume the view returns
          // a special <input> with new next-page data. We'll query for it
          // and update nextPageInput if found.

          const parser = new DOMParser();
          const doc = parser.parseFromString(data, 'text/html');
          const newNextPage = doc.querySelector('#next-page');
          if (newNextPage) {
            nextPageInput.value = newNextPage.value;
          } else {
            // If there's no next-page in the returned data, there's no more products
            nextPageInput.value = '';
            observer.unobserve(sentinel);
          }
        } catch (error) {
          console.error('Error loading more products:', error);
          observer.unobserve(sentinel);
        }

        // Hide spinner
        loadingSpinner.style.display = 'none';
      }
    });

    // Observe the sentinel
    observer.observe(sentinel);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    var form = document.getElementById('search-form');
    var input = document.getElementById('search-input');
    var l1 = document.getElementById('l1-field');
    var l2 = document.getElementById('l2-field');
    if (form && input && l1 && l2) {
      form.addEventListener('submit', function () {
        var v = (input.value || '').trim();
        var sep = ' - ';
        if (v.indexOf(sep) !== -1) {
          var parts = v.split(sep);
          l1.value = (parts[0] || '').trim();
          l2.value = (parts[1] || '').trim();
          input.value = '';
        }
      });
    }
  });
}</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Existing intersection observer code for infinite scroll ...
    
    // Show any Bootstrap toasts if there are messages
    var toastElList = [].slice.call(document.querySelectorAll('.toast'));
    var toastList = toastElList.map(function (toastEl) {
      return new bootstrap.Toast(toastEl);
    });
    toastList.forEach(toast => toast.show());
  });
</script>
<script>
document.addEventListener('DOMContentLoaded', function () {
  const form   = document.getElementById('search-form');
  const input  = document.getElementById('search-input');
  const l1f    = document.getElementById('l1-field');
  const l2f    = document.getElementById('l2-field');
  const L1     = JSON.parse(document.getElementById('level1-names').textContent || "[]");
  const L2     = JSON.parse(document.getElementById('level2-names').textContent || "[]");

  const fold = s => (s || '').toLocaleLowerCase();

  form.addEventListener('submit', function () {
    const v = input.value.trim();
    if (!v) return; // nothing to do

    // Combined "Level1 › Level2"
    if (v.includes('›')) {
      const [l1, l2] = v.split('›').map(s => s.trim());
      if (L1 - L2f.value = '';
    // Otherwise: leave as free-text fuzzy search
  });
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Only on small screens
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (!isMobile) return;

    if (sessionStorage.getItem('restoredScrollOnce') === '1') return;

    // Only after a search or category filter
    const params = new URLSearchParams(window.location.search);
    const didFilter = params.has('q') || params.has('l1') || params.has('l2');
    if (!didFilter) return;

    // Scroll to the first product card
    requestAnimationFrame(() => {
      // Grab the first rendered child within the product grid
      const firstItem = document.querySelector('#product-container > *');
      if (!firstItem) return;

      // If you have a fixed/sticky navbar, offset for it
      const header = document.querySelector('.sticky-top, .navbar, header');
      const offset = header ? header.getBoundingClientRect().height : 0;

      const y = firstItem.getBoundingClientRect().top + window.pageYOffset - offset - 8;
      window.scrollTo({ top: y, behavior: 'smooth' });
    });
  });
</script>
<script>
/**
 * Preserve scroll position across the add-to-cart redirect (esp. mobile).
 * - On submit of an .add-to-cart-form, store scrollY.
 * - On next load, restore it immediately.
 */
(function () {
  // Try to prevent browsers from auto-resetting scroll
  if ('scrollRestoration' in history) {
    history.scrollRestoration = 'manual';
  }

  // Restore scroll as early as possible on the new page
  if (sessionStorage.getItem('restoreAfterAdd') === '1') {
    var y = parseInt(sessionStorage.getItem('scrollYBeforeAdd') || '0', 10);
    if (!isNaN(y)) {
      window.scrollTo(0, y);
    }
    // Let other scripts know we've restored; clear shortly after
    sessionStorage.setItem('restoredScrollOnce', '1');
    setTimeout(function () {
      sessionStorage.removeItem('restoredScrollOnce');
    }, 1000);

    sessionStorage.removeItem('restoreAfterAdd');
    sessionStorage.removeItem('scrollYBeforeAdd');
  }

  // Capture submits on any current/future add-to-cart form (works with infinite scroll)
  document.addEventListener('submit', function (e) {
    var f = e.target;
    if (f && f.classList && f.classList.contains('add-to-cart-form')) {
      sessionStorage.setItem('scrollYBeforeAdd', String(window.scrollY));
      sessionStorage.setItem('restoreAfterAdd', '1');
    }
  }, true); // capture phase catches it even if forms are inside other handlers
})();
</script>
<script>
document.addEventListener('submit', function (e) {
  const f = e.target.closest('form.add-to-cart-form');
  if (!f) return;
  const good = f.dataset.actionUrl;
  if (good && f.getAttribute('action') !== good) {
    f.setAttribute('action', good);
  }
}, true);
</script>




{% endblock %}


