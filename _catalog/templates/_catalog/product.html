{% extends 'base.html' %}
{% load static %}

{% block title %}
  Product List - Online Grocery
{% endblock %}

{% block content %}
<div class="container">
  <h1>Product List</h1>

  <div class="row">
    <!-- Left Column: Collapsible Category Menu -->
    <div class="col-md-3 mb-4">
      <div class="card">
        <div class="card-header">
          <strong>Categories</strong>
        </div>

        <ul class="list-group list-group-flush">
          {% for level1, node in category_tree.items %}
            <li class="list-group-item">
              {% if node.items %}
                <a
                  class="d-flex justify-content-between align-items-center text-decoration-none"
                  data-bs-toggle="collapse"
                  href="#cat-{{ forloop.counter }}"
                  role="button"
                  aria-expanded="false"
                  aria-controls="cat-{{ forloop.counter }}"
                >
                  <strong>{{ level1 }}</strong>
                  <span class="ms-2"><i class="bi bi-caret-down-fill"></i></span>
                </a>

                <ul class="collapse ms-4 mt-2" id="cat-{{ forloop.counter }}" style="list-style-type: disc;">
                  {% for level2, _ in node.items %}
                    <li style="list-style-position: outside;">
                      <a class="text-decoration-none" href="?l1={{ level1|urlencode }}&l2={{ level2|urlencode }}">
                        {{ level2 }}
                      </a>
                    </li>
                  {% endfor %}
                </ul>
              {% else %}
                <a class="text-decoration-none d-block" href="?l1={{ level1|urlencode }}">
                  <strong>{{ level1 }}</strong>
                </a>
              {% endif %}
            </li>
          {% empty %}
            <li class="list-group-item text-muted">No categories found.</li>
          {% endfor %}
        </ul>

      </div>
    </div>

    <!-- Right Column: Search Form & Product Listing -->
    <div class="col-md-9">
      <!-- Search Form -->
      {% comment %} <form method="GET" action="" class="mb-3">
        <div class="input-group">
          <input
            type="text"
            name="q"
            class="form-control"
            placeholder="Search for products..."
            value="{{ request.GET.q }}"
          />
          <button class="btn btn-outline-secondary" type="submit">
            Search
          </button>
        </div>
      </form> {% endcomment %}

<form method="GET" action="" class="mb-3" id="search-form">
  {# preserve current filters when searching #}
  {% if request.GET.l1 %}<input type="hidden" name="l1" id="l1-field" value="{{ request.GET.l1 }}">{% else %}<input type="hidden" name="l1" id="l1-field">{% endif %}
  {% if request.GET.l2 %}<input type="hidden" name="l2" id="l2-field" value="{{ request.GET.l2 }}">{% else %}<input type="hidden" name="l2" id="l2-field">{% endif %}

  <div class="input-group">
    <input
      type="text"
      name="q"
      id="search-input"
      class="form-control"
      placeholder="Search for products or categories..."
      value="{{ request.GET.q }}"
      list="category-suggestions"
      autocomplete="off"
    />
    <button class="btn btn-outline-secondary" type="submit">
      Search
    </button>
  </div>

  {# As-you-type dropdown suggestions: Level-1, Level-2, and combined "L1 › L2" #}
  <datalist id="category-suggestions">
    {% for level1, node in category_tree.items %}
      <option value="{{ level1 }}"></option>
      {% if node.items %}
        {% for level2, _ in node.items %}
          <option value="{{ level2 }}"></option>
          <option value="{{ level1 }} › {{ level2 }}"></option>
        {% endfor %}
      {% endif %}
    {% endfor %}
  </datalist>
</form>

{# Safe JSON payloads for exact-matching on submit #}
{{ level1_names|json_script:"level1-names" }}
{{ level2_names|json_script:"level2-names" }}

      

      <!-- Product Container -->
      <!-- We'll insert initial products here, and then append more as the user scrolls -->
      <div class="row gy-4" id="product-container">
        {% for product in products %}
          {% include '_catalog/product_item.html' with product=product %}
        {% endfor %}
      </div>

      <!-- A hidden element to store the next page number or URL -->
{% if page_obj.has_next %}
  <input type="hidden" id="next-page" value="{{ page_obj.next_page_number }}">
{% else %}
  <input type="hidden" id="next-page" value="">
{% endif %}

      <!-- Sentinel DIV for the Intersection Observer -->
      <div id="infinite-scroll-sentinel" class="py-3 text-center">
        <!-- We'll watch this element to trigger loads -->
        <span id="loading-spinner" style="display: none;">
          <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading more products...</span>
          </div>
        </span>
      </div>

    </div> <!-- End Right Column -->
  </div> <!-- End .row -->
</div>

<!-- JavaScript for Infinite Scroll -->
<script>
  document.addEventListener('DOMContentLoaded', function () {
    const sentinel = document.getElementById('infinite-scroll-sentinel');
    const loadingSpinner = document.getElementById('loading-spinner');
    const nextPageInput = document.getElementById('next-page');
    const productContainer = document.getElementById('product-container');

    // If there's no next page, we can disable infinite scroll
    if (!nextPageInput.value) {
      // No more pages to load
      return;
    }

    // Create an Intersection Observer
    const observer = new IntersectionObserver(async (entries) => {
      if (entries.some(e => e.isIntersecting)) {
        loadingSpinner.style.display = 'inline-block';
        let page = nextPageInput.value;

        try {
          let url = "{% url 'load_more_products' %}?page=" + page;

          {% if request.GET.q %}
          url += "&q={{ request.GET.q|urlencode }}";
          {% endif %}

          // Always forward current l1/l2 from the URL
          const params = new URLSearchParams(window.location.search);
          if (params.get('l1')) url += "&l1=" + encodeURIComponent(params.get('l1'));
          if (params.get('l2')) url += "&l2=" + encodeURIComponent(params.get('l2'));


          // Fetch the next set of products (HTML or JSON)
          const response = await fetch(url, {
            headers: {
              'X-Requested-With': 'XMLHttpRequest'
            }
          });
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }

          // Let's assume it returns HTML to be appended
          const data = await response.text();

          // Append the returned HTML to the product container
          productContainer.insertAdjacentHTML('beforeend', data);

          // We'll assume the partial includes a <script> or a hidden input
          // that updates or includes the new "next_page" value. Alternatively,
          // return it via a custom header or JSON. For simplicity, let's say
          // the view returns JSON with new HTML and next_page.

          // But if you're returning pure HTML, you must find a way to update
          // the next page. For demonstration, let's assume the view returns
          // a special <input> with new next-page data. We'll query for it
          // and update nextPageInput if found.

          const parser = new DOMParser();
          const doc = parser.parseFromString(data, 'text/html');
          const newNextPage = doc.querySelector('#next-page');
          if (newNextPage) {
            nextPageInput.value = newNextPage.value;
          } else {
            // If there's no next-page in the returned data, there's no more products
            nextPageInput.value = '';
            observer.unobserve(sentinel);
          }
        } catch (error) {
          console.error('Error loading more products:', error);
          observer.unobserve(sentinel);
        }

        // Hide spinner
        loadingSpinner.style.display = 'none';
      }
    });

    // Observe the sentinel
    observer.observe(sentinel);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Existing intersection observer code for infinite scroll ...
    
    // Show any Bootstrap toasts if there are messages
    var toastElList = [].slice.call(document.querySelectorAll('.toast'));
    var toastList = toastElList.map(function (toastEl) {
      return new bootstrap.Toast(toastEl);
    });
    toastList.forEach(toast => toast.show());
  });
</script>
<script>
document.addEventListener('DOMContentLoaded', function () {
  const form   = document.getElementById('search-form');
  const input  = document.getElementById('search-input');
  const l1f    = document.getElementById('l1-field');
  const l2f    = document.getElementById('l2-field');
  const L1     = JSON.parse(document.getElementById('level1-names').textContent || "[]");
  const L2     = JSON.parse(document.getElementById('level2-names').textContent || "[]");

  const fold = s => (s || '').toLocaleLowerCase();

  form.addEventListener('submit', function () {
    const v = input.value.trim();
    if (!v) return; // nothing to do

    // Combined "Level1 › Level2"
    if (v.includes('›')) {
      const [l1, l2] = v.split('›').map(s => s.trim());
      if (l1 && l2) {
        l1f.value = l1;
        l2f.value = l2;
        input.value = ''; // prevent fuzzy search; we want exact l1/l2
        return;
      }
    }

    // Exact Level-1 match -> use l1 param, clear q
    const l1Hit = L1.find(x => fold(x) === fold(v));
    if (l1Hit) {
      l1f.value = l1Hit;
      l2f.value = '';
      input.value = ''; // no fuzzy search
      return;
    }

    // Exact Level-2 match -> leave q as-is (server's exact-match logic will kick in)
    const l2Hit = L2.find(x => fold(x) === fold(v));
    if (l2Hit) {
      // Keep input.value; do not set l1/l2 (let backend exact-match on q)
      return;
    }

    // Otherwise: leave as free-text fuzzy search
  });
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Only on small screens
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (!isMobile) return;

    // Only after a search or category filter
    const params = new URLSearchParams(window.location.search);
    const didFilter = params.has('q') || params.has('l1') || params.has('l2');
    if (!didFilter) return;

    // Scroll to the first product card
    requestAnimationFrame(() => {
      // Grab the first rendered child within the product grid
      const firstItem = document.querySelector('#product-container > *');
      if (!firstItem) return;

      // If you have a fixed/sticky navbar, offset for it
      const header = document.querySelector('.sticky-top, .navbar, header');
      const offset = header ? header.getBoundingClientRect().height : 0;

      const y = firstItem.getBoundingClientRect().top + window.pageYOffset - offset - 8;
      window.scrollTo({ top: y, behavior: 'smooth' });
    });
  });
</script>


{% endblock %}
